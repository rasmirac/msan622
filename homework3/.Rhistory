output$scatterPlot <- renderPlot(
{
# Use our function to generate the plot.
scatterPlot <- firstPlot(
localFrame
)
# Output the plot
print(scatterPlot)
}
)
output$bubblePlot <- renderPlot(
{
# Use our function to generate the plot.
bubblePlot <- bubblePlot(
localFrame
)
# Output the plot
print(bubblePlot)
}
)
})
runApp()
runApp()
runApp()
runApp()
?unit
??unit
library(scales)
??unit
library(ggplot2)
library(shiny)
library(GGally)
library(scales)
library(grid)
df <- data.frame(state.x77,
State = state.name,
Abbrev = state.abb,
Region = state.region,
Division = state.division )
# Label formatter for numbers in thousands.
thousand_formatter <- function(x) {
return(sprintf("%dk", round(x / 1000)))
}
# Create plotting function.
firstPlot <- function(localFrame) {
p <- ggpairs(localFrame,
# Columns to include in the matrix
columns = 2:6,
# What to include above diagonal
# list(continuous = "points") to mirror
# "blank" to turn off
upper = "blank",
# What to include below diagonal
lower = list(continuous = "points"),
# What to include in the diagonal
diag = list(continuous = "density"),
# How to label inner plots
# internal, none, show
axisLabels = "none",
# Other aes() parameters
colour = "Region",
title = "Iris Scatterplot Matrix"
)
# Remove grid from plots along diagonal
for (i in 1:5) {
# Get plot out of matrix
inner = getPlot(p, i, i);
# Add any ggplot2 settings you want
inner = inner + theme(panel.grid = element_blank());
# Put it back into the matrix
p <- putPlot(p, inner, i, i);
}
return(p)
}
secondPlot <- function(localFrame){
p <- ggplot(localFrame, aes(
x = Population,
y = Income,
color = Region,
size = Murder))
# Give points some alpha to help with overlap/density
# Can also "jitter" to reduce overlap but reduce accuracy
p <- p + geom_point(alpha = 0.6)
# Default size scale is by radius, force to scale by area instead
# Optionally disable legends
p <- p + scale_size_area(max_size = 10, guide = "none")
# p <- p + scale_color_discrete(guide = "none")
# Tweak the plot limits
#  p <- p + scale_x_continuous(
#    limits = c(3, 9),
#    expand = c(0, 0))
#  p <- p + scale_y_continuous(
#    limits = c(1, 5),
#    expand = c(0, 0))
# Make the grid square
p <- p + coord_fixed(ratio = 1)
# Modify the labels
p <- p + ggtitle("Income, Murder, Population")
p <- p + labs(
size = "Murder Rate",
x = "Population",
y = "Income")
# Modify the legend settings
p <- p + theme(legend.title = element_blank())
p <- p + theme(legend.direction = "horizontal")
p <- p + theme(legend.position = c(0, 0))
p <- p + theme(legend.justification = c(0, 0))
p <- p + theme(legend.background = element_blank())
p <- p + theme(legend.key = element_blank())
p <- p + theme(legend.text = element_text(size = 12))
p <- p + theme(legend.margin = unit(0, "pt"))
# Force the dots to plot larger in legend
p <- p + guides(colour = guide_legend(override.aes = list(size = 8)))
# Indicate size is petal length
p <- p + annotate(
"text", x = 6, y = 4.8,
hjust = 0.5, color = "grey40",
label = "Circle area is proportional to murder rate")
return(p)
}
##### SHINY SERVER #####
# Create shiny server. Input comes from the UI input
# controls, and the resulting output will be displayed on
# the page.
shinyServer(function(input, output) {
cat("Press \"ESC\" to exit...\n")
localFrame <- df
# Output scatter plot.
# Should update every time sort or color criteria changes.
output$scatterPlot <- renderPlot(
{
# Use our function to generate the plot.
scatterPlot <- firstPlot(
localFrame
)
# Output the plot
print(scatterPlot)
}
)
output$bubblePlot <- renderPlot(
{
# Use our function to generate the plot.
bubblePlot <- secondPlot(
localFrame
)
# Output the plot
print(bubblePlot)
}
)
})
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?scale_size_area
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?scale_x_continuous
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?round
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?panel.background
?theme
?rect
runApp()
runApp()
runApp()
?theme
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
View(df)
View(df)
runApp()
runApp()
levels(df$Region)
runApp()
runApp()
runApp()
runApp()
runApp()
?brewer_pal
runApp()
runApp()
?ggpairs
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
levels(df$Region)
runApp()
?ggtext
??ggtext
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?geom_point
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?ggparcoord
runApp()
runApp()
highlights <- c('North', 'South')
which[df$Region %in% highlight]
which[df$Region %in% highlights]
my_palette <- brewer_pal(type = "qual", palette = 'Pastel2')(length(levels(df$Region)))
my_palette[which[df$Region %in% highlights]]
my_palette[which[df$Region %in% highlights],]
my_palette[,which[df$Region %in% highlights]]
which(df$Region %in% highlights)
which(levels(df$Region) %in% highlights)
levels(df$Region)
my_palette[which(levels(df$Region) %in% highlights)]
runApp()
runApp()
runApp()
runApp()
runApp()
?state.77
?state.x77
df <- data.frame(state.x77,
Population = as.numeric(Population),
Income = as.numeric(Income),
Illiteracy = as.numeric(Illiteracy),
Life.Exp = as.numeric(Life.Exp),
Murder = as.numeric(Murder),
HS.Grad = as.numeric(HS.Grad),
State = state.name,
Abbrev = state.abb,
Region = as.factor(state.region),
Division = state.division)
df <- data.frame(state.x77,
Population = as.numeric(Population),
Income = as.numeric(Income),
Illiteracy = as.numeric(Illiteracy),
Life.Exp = as.numeric(Life.Exp),
Murder = as.numeric(Murder),
HS.Grad = as.numeric(HS.Grad),
State = state.name,
Abbrev = state.abb,
Region = as.factor(state.region),
Division = state.division)
df <- data.frame(state.x77,
State = state.name,
Abbrev = state.abb,
Region = as.factor(state.region),
Division = state.division)
sapply(df, type)
?type
sapply(df, typeof)
df <- as.numeric(df[,seq(2, 8)])
df[,seq(2, 8)]
as.numeric(df[,seq(2, 8)])
?as.numeric
sapply(df[,seq(2,8)], as.numeric)
df[,seq(2,8)] <- sapply(df[,seq(2,8)], as.numeric)
runApp()
runApp()
runApp()
runApp()
runApp()
which.min(df$Illiteracy)
df[15,]
which.max(df$Illiteracy)
df[18,]
which.max(df$Murder)
df[1,]
runApp()
runApp()
?theme
runApp()
runApp()
runApp()
runApp()
head(df)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?selectInput
names(df[,seq(2:8)])
names(df[,seq(2:9)])
names(df[,seq(2:8)]) <- c("Population",
"Income",
"Illiteracy Rate",
"Life Expectancy",
"Murder",
"High School Graduates",
"Frost",
'Area')
names(df[,seq(2:9)]) <- c("Population",
"Income",
"Illiteracy Rate",
"Life Expectancy",
"Murder",
"High School Graduates",
"Frost",
'Area')
runApp()
df[, c('Murder Rate')]
df[, c('Murder.Rate')]
df <- data.frame(state.x77,
State = state.name,
Abbrev = state.abb,
Region = as.factor(state.region),
Division = state.division)
names(df[,seq(2:9)]) <- c("Population",
"Income",
"Illiteracy Rate",
"Life Expectancy",
"Murder Rate",
"High School Graduates",
"Frost",
'Area')
df[, c('Murder.Rate')]
df[, 'Murder.Rate']
df$Murder.Rate
View(df)
names(df[,seq(2, 9)])
names(df[,seq(2, 9)]) <- c("Population",
"Income",
"Illiteracy Rate",
"Life Expectancy",
"Murder Rate",
"High School Graduates",
"Frost",
'Area')
names(df[,seq(2, 9)])
colnames(df[,seq(2:9)])
colnames(df[,seq(2:9)]) <- c("Population",
"Income",
"Illiteracy Rate",
"Life Expectancy",
"Murder Rate",
"High School Graduates",
"Frost",
'Area')
colnames(df[,seq(2:9)])
colnames(df)[2:9]
colnames(df)[2:9] <- c("Population",
"Income",
"Illiteracy Rate",
"Life Expectancy",
"Murder Rate",
"High School Graduates",
"Frost",
'Area')
colnames(df)[2:9]
runApp()
names(df[,seq(2, 9)])
df$Murder.Rate
df[, 'Murder.Rate']
df[, c('Murder.Rate')]
df[, c('Murder Rate')]
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
View(df)
xAxis <- 'Murder Rate'
localFrame[, c(xAxis)]
df[, c(xAxis)]
runApp()
runApp()
colnames(df)
df <- data.frame(state.x77,
State = state.name,
Abbrev = state.abb,
Region = as.factor(state.region),
Division = state.division)
colnames(df)
View(df)
colnames(df)[2:9] <- c("Population",
"Income",
"Illiteracy Rate",
"Life Expectancy",
"Murder Rate",
"High School Graduates",
"Frost",
'Area')
View(df)
colnames(df)
View(df)
df <- data.frame(state.x77,
State = state.name,
Abbrev = state.abb,
Region = as.factor(state.region),
Division = state.division)
colnames(df)[1:8] <- c("Population",
"Income",
"Illiteracy Rate",
"Life Expectancy",
"Murder Rate",
"High School Graduates",
"Frost",
'Area')
colnames(df)
View(df)
runApp()
min(df[,c('Murder Rate')])
runApp()
runApp()
colnames(df)
View(df)
runApp()
#scale_y_continuous(limits = c(min(localFrame[,c(yAxis)]), max(localFrame[,c(yAxis)]))) +
labs(
s
a
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
print(c('cat', 'dog'))
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
